// Code generated by entify, DO NOT EDIT.

package {{.Package}}


import (
	"context"
	"fmt"
    "math"

    "entgo.io/ent/dialect/sql"
    "{{.Module}}/predicate"
    "{{.Module}}/{{.Entity.PackageName}}"
)

type {{.Entity.StructName}}Query struct {
	client *{{.Entity.StructName}}Client

    limit      *int
	offset     *int
	unique     *bool
	order      []OrderFunc
	fields     []string
    predicates []predicate.{{.Entity.StructName}}

    sql  *sql.Selector
}

func ({{.Entity.ReceiverVarName}}q *{{.Entity.StructName}}Query) prepareQuery(ctx context.Context) error {
	for _, f := range {{.Entity.ReceiverVarName}}q.fields {
		if !{{.Entity.PackageName}}.ValidColumn(f) {
			return fmt.Errorf("entify: invalid field %q for query", f)
		}
	}

	return nil
}

func ({{.Entity.ReceiverVarName}}q *{{.Entity.StructName}}Query) sqlQuery(ctx context.Context) *sql.Selector {
	builder := sql.Dialect({{.Entity.ReceiverVarName}}q.client.dialect)

	t1 := builder.Table({{.Entity.PackageName}}.Table)

	columns := {{.Entity.ReceiverVarName}}q.fields
	if len(columns) == 0 {
		columns = {{.Entity.PackageName}}.Columns
	}

    selector := builder.Select(t1.Columns(columns...)...).From(t1)
	if {{.Entity.ReceiverVarName}}q.sql != nil {
		selector = {{.Entity.ReceiverVarName}}q.sql
		selector.Select(selector.Columns(columns...)...)
	}

	if {{.Entity.ReceiverVarName}}q.unique != nil && *{{.Entity.ReceiverVarName}}q.unique {
		selector.Distinct()
	}

	for _, p := range {{.Entity.ReceiverVarName}}q.predicates {
		p(selector)
	}

	for _, p := range {{.Entity.ReceiverVarName}}q.order {
		p(selector)
	}

	if offset := {{.Entity.ReceiverVarName}}q.offset; offset != nil {
		// limit is mandatory for offset clause. We start
		// with default value, and override it below if needed.
		selector.Offset(*offset).Limit(math.MaxInt32)
	}

	if limit := {{.Entity.ReceiverVarName}}q.limit; limit != nil {
		selector.Limit(*limit)
	}

	return selector
}


func ({{.Entity.ReceiverVarName}}q *{{.Entity.StructName}}Query) Select(fields ...string) *{{.Entity.StructName}}Select {
	{{.Entity.ReceiverVarName}}q.fields = append({{.Entity.ReceiverVarName}}q.fields, fields...)

	return &{{.Entity.StructName}}Select{
        {{.Entity.StructName}}Query: {{.Entity.ReceiverVarName}}q,
    }
}

func ({{.Entity.ReceiverVarName}}q *{{.Entity.StructName}}Query) Where(ps ...predicate.{{.Entity.StructName}}) *{{.Entity.StructName}}Query {
	{{.Entity.ReceiverVarName}}q.predicates = append({{.Entity.ReceiverVarName}}q.predicates, ps...)

	return {{.Entity.ReceiverVarName}}q
}

{{- range .Entity.PrimaryKeys }}
// {{$.Entity.PackageName}}s executes the query and returns a list of {{$.Entity.StructName}} {{.PropertyName}}s.
func ({{$.Entity.ReceiverVarName}}q *{{$.Entity.StructName}}Query) {{.PropertyName}}s(ctx context.Context) ([]{{.Type}}, error) {
	var {{.VariableName}}s []{{.Type}}
	if err := {{$.Entity.ReceiverVarName}}q.Select({{$.Entity.PackageName}}.Field{{.PropertyName}}).Scan(ctx, &{{.VariableName}}s); err != nil {
		return nil, err
	}

	return {{.VariableName}}s, nil
}
{{- end}}

func ({{.Entity.ReceiverVarName}}q *{{.Entity.StructName}}Query) FindOne(ctx context.Context, query string, args ...interface{}) (*{{.Entity.StructName}}, error) {
	rows, err := {{.Entity.ReceiverVarName}}q.client.db.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("update failed: %w", err)
	}

	defer rows.Close()

	columns, err := rows.Columns()
	if err != nil {
		return nil, fmt.Errorf("get columns failed: %w", err)
	}

	{{.Entity.ReceiverVarName}} := &{{.Entity.StructName}}{
		client: {{.Entity.ReceiverVarName}}q.client,
	}

	for rows.Next() {
		values, err := {{.Entity.ReceiverVarName}}.scanValues(columns)
		if err != nil {
			return nil, fmt.Errorf("{{.Entity.StructName}} scan values from columns failed: %w", err)
		}

		if err := rows.Scan(values...); err != nil {
			return nil, fmt.Errorf("scan row to values failed: %w", err)
		}

		if err := {{.Entity.ReceiverVarName}}.assignValues(columns, values); err != nil {
			return nil, fmt.Errorf("{{.Entity.StructName}} assign values failed: %w", err)
		}

		break
	}

	return {{.Entity.ReceiverVarName}}, rows.Err()
}

func ({{.Entity.ReceiverVarName}}q *{{.Entity.StructName}}Query) FindAll(ctx context.Context, query string, args ...interface{}) ([]*{{.Entity.StructName}}, error) {
	rows, err := {{.Entity.ReceiverVarName}}q.client.db.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("update failed: %w", err)
	}

	defer rows.Close()

	columns, err := rows.Columns()
	if err != nil {
		return nil, fmt.Errorf("get columns failed: %w", err)
	}

	items := []*{{.Entity.StructName}}{}

	for rows.Next() {
		{{.Entity.ReceiverVarName}} := &{{.Entity.StructName}}{
			client: {{.Entity.ReceiverVarName}}q.client,
		}

		values, err := {{.Entity.ReceiverVarName}}.scanValues(columns)
		if err != nil {
			return nil, fmt.Errorf("{{.Entity.StructName}} scan values from columns failed: %w", err)
		}

		if err := rows.Scan(values...); err != nil {
			return nil, fmt.Errorf("scan row to values failed: %w", err)
		}

		if err := {{.Entity.ReceiverVarName}}.assignValues(columns, values); err != nil {
			return nil, fmt.Errorf("{{.Entity.StructName}} assign values failed: %w", err)
		}

		items = append(items, {{.Entity.ReceiverVarName}})
	}

	return items, rows.Err()
}



// {{.Entity.StructName}}Select is the builder for selecting fields of {{.Entity.StructName}} entities.
type {{.Entity.StructName}}Select struct {
	*{{.Entity.StructName}}Query
    sql *sql.Selector
}

// Scan applies the selector query and scans the result into the given value.
func ({{$.Entity.ReceiverVarName}}s *{{$.Entity.StructName}}Select) Scan(ctx context.Context, v interface{}) error {
	if err := {{$.Entity.ReceiverVarName}}s.prepareQuery(ctx); err != nil {
		return err
	}

	{{$.Entity.ReceiverVarName}}s.sql = {{$.Entity.ReceiverVarName}}s.{{$.Entity.StructName}}Query.sqlQuery(ctx)

	return {{$.Entity.ReceiverVarName}}s.sqlScan(ctx, v)
}

func ({{$.Entity.ReceiverVarName}}s *{{$.Entity.StructName}}Select) sqlScan(ctx context.Context, v interface{}) error {
	query, args := {{$.Entity.ReceiverVarName}}s.sql.Query()

	rows, err := {{.Entity.ReceiverVarName}}s.client.db.QueryContext(ctx, query, args...)
	if err != nil {
		return fmt.Errorf("select failed: %w", err)
	}
	defer rows.Close()

	return sql.ScanSlice(rows, v)
}

func ({{$.Entity.ReceiverVarName}}s *{{$.Entity.StructName}}Select) ScanQuery(ctx context.Context, v interface{}, query string, args ...interface{}) error {
	rows, err := {{.Entity.ReceiverVarName}}s.client.db.QueryContext(ctx, query, args...)
	if err != nil {
		return fmt.Errorf("exec query failed: %w", err)
	}
	defer rows.Close()

	return sql.ScanSlice(rows, v)
}
