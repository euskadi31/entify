// Code generated by entify, DO NOT EDIT.

package {{.Package}}

import (
    "database/sql"
    "fmt"
	{{- range .Entity.Imports}}
    "{{.}}"
    {{- end}}

	"{{.Module}}/{{.Entity.PackageName}}"
)

type {{.Entity.StructName}} struct {
	client   *{{.Entity.StructName}}Client

    {{- range .Entity.Fields}}
    {{.VariableName}} {{.Type}}
    {{- end}}
}

func ({{.Entity.ReceiverVarName}} *{{.Entity.StructName}}) Update() *{{.Entity.StructName}}UpdateOne {
	return &{{.Entity.StructName}}UpdateOne{
		mutation: new{{.Entity.StructName}}Mutation({{.Entity.ReceiverVarName}}.client, OpUpdateOne, with{{$.Entity.StructName}}({{.Entity.ReceiverVarName}})),
	}
}

func ({{.Entity.ReceiverVarName}} *{{.Entity.StructName}}) Delete() *{{.Entity.StructName}}DeleteOne {
	return &{{.Entity.StructName}}DeleteOne{
		mutation: new{{.Entity.StructName}}Mutation({{.Entity.ReceiverVarName}}.client, OpDeleteOne, with{{$.Entity.StructName}}ID(
            {{- range .Entity.PrimaryKeys}}
            {{$.Entity.ReceiverVarName}}.{{.VariableName}},
            {{- end}}
        )),
	}
}

{{range .Entity.Fields}}
func ({{$.Entity.ReceiverVarName}} *{{$.Entity.StructName}}) Get{{.PropertyName}}() {{.Type}} {
	return {{$.Entity.ReceiverVarName}}.{{.VariableName}}
}
{{end}}

// scanValues returns the types for scanning values from sql.Rows.
func (*{{.Entity.StructName}}) scanValues(columns []string) ([]interface{}, error) {
	values := make([]interface{}, len(columns))

	for i := range columns {
		switch columns[i] {
        {{range .Entity.Fields}}
        case {{$.Entity.PackageName}}.Field{{.PropertyName}}:
            values[i] = new({{.SQLType}})
        {{end}}
		default:
			return nil, fmt.Errorf("unexpected column %q for type {{.Entity.StructName}}", columns[i])
		}
	}

	return values, nil
}


// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the {{.Entity.StructName}} fields.
func ({{.Entity.ReceiverVarName}} *{{.Entity.StructName}}) assignValues(columns []string, values []interface{}) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}

    for i := range columns {
		switch columns[i] {
        {{- range .Entity.Fields}}
		case {{$.Entity.PackageName}}.Field{{.PropertyName}}:
            if value, ok := values[i].(*{{.SQLType}}); !ok {
				return fmt.Errorf("unexpected type %T for field {{.Name}}", values[i])
			} else if value.Valid {
                {{ $.Entity.ReceiverVarName }}.{{ .VariableName }} = {{.Type}}(value.{{ .NullableSQLAccessValue }})
			}
		{{- end}}
		}
	}

	return nil
}
